const e=JSON.parse('{"key":"v-2d66a061","path":"/frontEnd/vue3/%E9%98%B6%E6%AE%B5%E4%BA%8C/05Vue3%E2%80%94Composition-API.html","title":"Vue3—Composition-API","lang":"zh-CN","frontmatter":{"title":"Vue3—Composition-API","icon":"bijiben","category":"vue","order":5,"description":"Options API的弊端 API风格| Vue.js (vuejs.org) 在Vue2中，我们编写组件的方式是Options API（选项式API）： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命周期钩子； 但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的","head":[["meta",{"property":"og:url","content":"https://ycyang.site/blog/frontEnd/vue3/%E9%98%B6%E6%AE%B5%E4%BA%8C/05Vue3%E2%80%94Composition-API.html"}],["meta",{"property":"og:site_name","content":"寒舞知识宝库"}],["meta",{"property":"og:title","content":"Vue3—Composition-API"}],["meta",{"property":"og:description","content":"Options API的弊端 API风格| Vue.js (vuejs.org) 在Vue2中，我们编写组件的方式是Options API（选项式API）： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命周期钩子； 但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-05T04:24:03.000Z"}],["meta",{"property":"article:author","content":"Mr.DanceCold"}],["meta",{"property":"article:modified_time","content":"2023-09-05T04:24:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue3—Composition-API\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-09-05T04:24:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.DanceCold\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Options API的弊端","slug":"options-api的弊端","link":"#options-api的弊端","children":[]},{"level":2,"title":"认识Composition API","slug":"认识composition-api","link":"#认识composition-api","children":[]},{"level":2,"title":"setup函数的参数","slug":"setup函数的参数","link":"#setup函数的参数","children":[{"level":3,"title":"Setup初体验-计数器","slug":"setup初体验-计数器","link":"#setup初体验-计数器","children":[]},{"level":3,"title":"Setup函数的返回值","slug":"setup函数的返回值","link":"#setup函数的返回值","children":[]},{"level":3,"title":"setup不可以使用this","slug":"setup不可以使用this","link":"#setup不可以使用this","children":[]}]},{"level":2,"title":"setup语法糖（顶层写法）","slug":"setup语法糖-顶层写法","link":"#setup语法糖-顶层写法","children":[]},{"level":2,"title":"顶层setup的组件传值","slug":"顶层setup的组件传值","link":"#顶层setup的组件传值","children":[]},{"level":2,"title":"Reactive API","slug":"reactive-api","link":"#reactive-api","children":[{"level":3,"title":"Reactive应用场景","slug":"reactive应用场景","link":"#reactive应用场景","children":[]}]},{"level":2,"title":"补充","slug":"补充","link":"#补充","children":[{"level":3,"title":"数组异步赋值问题","slug":"数组异步赋值问题","link":"#数组异步赋值问题","children":[]}]},{"level":2,"title":"Ref API","slug":"ref-api","link":"#ref-api","children":[{"level":3,"title":"ref读取dom元素","slug":"ref读取dom元素","link":"#ref读取dom元素","children":[]},{"level":3,"title":"toRefs","slug":"torefs","link":"#torefs","children":[]},{"level":3,"title":"toRef","slug":"toref","link":"#toref","children":[]},{"level":3,"title":"ref其他API","slug":"ref其他api","link":"#ref其他api","children":[]}]},{"level":2,"title":"Ref自动解包","slug":"ref自动解包","link":"#ref自动解包","children":[]},{"level":2,"title":"readonly","slug":"readonly","link":"#readonly","children":[{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]}]},{"level":2,"title":"Reactive判断的API","slug":"reactive判断的api","link":"#reactive判断的api","children":[{"level":3,"title":"isProxy","slug":"isproxy","link":"#isproxy","children":[]},{"level":3,"title":"isReactive","slug":"isreactive","link":"#isreactive","children":[]},{"level":3,"title":"isReadonly","slug":"isreadonly","link":"#isreadonly","children":[]},{"level":3,"title":"toRaw","slug":"toraw","link":"#toraw","children":[]},{"level":3,"title":"shallowReactive","slug":"shallowreactive","link":"#shallowreactive","children":[]},{"level":3,"title":"shallowReadonly","slug":"shallowreadonly","link":"#shallowreadonly","children":[]},{"level":3,"title":"customRef","slug":"customref","link":"#customref","children":[]}]},{"level":2,"title":"计算属性","slug":"计算属性","link":"#计算属性","children":[{"level":3,"title":"自定义get","slug":"自定义get","link":"#自定义get","children":[]}]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"Provide-Inject","slug":"provide-inject","link":"#provide-inject","children":[]},{"level":2,"title":"侦听器","slug":"侦听器","link":"#侦听器","children":[{"level":3,"title":"复杂数据侦听","slug":"复杂数据侦听","link":"#复杂数据侦听","children":[]},{"level":3,"title":"watchEffect","slug":"watcheffect","link":"#watcheffect","children":[]},{"level":3,"title":"停止侦听","slug":"停止侦听","link":"#停止侦听","children":[]}]},{"level":2,"title":"hooks函数抽取","slug":"hooks函数抽取","link":"#hooks函数抽取","children":[]},{"level":2,"title":"简单的组件之间切换标题","slug":"简单的组件之间切换标题","link":"#简单的组件之间切换标题","children":[{"level":3,"title":"一个组件中多次切换标题","slug":"一个组件中多次切换标题","link":"#一个组件中多次切换标题","children":[]}]},{"level":2,"title":"获取window的滚动位置","slug":"获取window的滚动位置","link":"#获取window的滚动位置","children":[]}],"git":{"createdTime":1693213043000,"updatedTime":1693887843000,"contributors":[{"name":"hanwu","email":"hanwu1314@outlook.com","commits":4}]},"readingTime":{"minutes":16.67,"words":5002},"filePathRelative":"frontEnd/vue3/阶段二/05Vue3—Composition-API.md","localizedDate":"2023年8月28日","excerpt":"<h2> Options API的弊端</h2>\\n<p><a href=\\"https://cn.vuejs.org/guide/introduction.html#api-styles\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">API风格| Vue.js (vuejs.org)</a></p>\\n<p>在Vue2中，我们编写组件的方式是Options API（选项式API）：</p>\\n<ul>\\n<li>Options API的一大特点就是在<span style=\\"color:#00b0f0\\">对应的属性中</span>编写对应的功能模块；</li>\\n<li>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命周期钩子；<br>\\n<strong>但是这种代码有一个很大的弊端：</strong></li>\\n<li>当我们实现某一个功能时，这个功能对应的代码逻辑会被<span style=\\"color:#00b0f0\\">拆分到各个属性</span>中；</li>\\n<li>当我们组件变得更大、更复杂时，<span style=\\"color:#00b0f0\\">逻辑关注点的列表就会增长</span>，那么同一个功能的逻辑就会被<span style=\\"color:#00b0f0\\">拆分的很分散</span>；</li>\\n<li>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是<span style=\\"color:#00b0f0\\">难以阅读和理解</span>的</li>\\n</ul>","copyright":{"author":"Mr.DanceCold"},"autoDesc":true}');export{e as data};
